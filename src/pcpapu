#!/usr/bin/env python3

# PCPAPU - Packet Capture Processor And Publising Utility

"""
PCPAPU - Packet Capture Processor And Publishing Utility
This module/program contains code used for the interactive tool pcpapu.
Should the tool need to be extended without modifying this file,
it can be imported and extended programatically.
"""
import sys
import argparse

import time

import readline
import code

from packet import common
from packet.capfile import pcap

from packet.identity import core as identity_core

from packet.pipeline.merge import merge
from packet.pipeline.identify import identify
from packet.pipeline.filter import filter


def build_prototype_list(attrdefstrs):
    attrlist = []
    for attrdefstr in attrdefstrs.split("/"):
        protoname, _, attrstr = attrdefstr.partition(":")
        protocol = identity_core.lookup_protocol(protoname)
        attrlist.append((protocol.name, protocol.build_attributes(attrstr)))
    return attrlist


def help_prog(argv):
    helptext = """{0}: Packet Caputre Processor And Publishing Utility.
Usage: {0} [subcommand] [arguments]
Valid subcommands are: help, merge, filter.
Use "{0} [subcommand] --help" for help with a subcommand."""
    print(helptext.format(argv[0]))


def merge_prog(argv):
    # Set up the argument parser.
    parser = argparse.ArgumentParser(prog="{0} {1}".format(argv[0], argv[1]), description="Merge packet captures and adjust their times.")
    parser.add_argument("-i", "--in", type=argparse.FileType("rb"), dest="inpaths", action="append", help="Input files")
    parser.add_argument("-o", "--out", type=argparse.FileType("wb"), dest="outpath", action="store", help="Output file")
    parser.add_argument("-r", "--relative", dest="relative", action="store_const", const=True, default=True, help="Use relative times. (Default)")
    parser.add_argument("-a", "--absolute", dest="relative", action="store_const", const=False, default=True, help="Do not use relative times.")
    parser.add_argument("-t", "--time-offset", type=(lambda d: time.mktime(time.strptime(d, "%Y/%m/%d %H:%M:%S"))), dest="time_offset", action="store", default=None, help="Time offset, in Y/M/D H:M:S format.")
    # Y/M/D H:M:S == "%Y/%m/%d %H:%M:%S"

    arguments = parser.parse_args(argv[2:])

    if arguments.inpaths == None:
        arguments.inpaths = [sys.stdin.buffer]
    if arguments.outpath == None:
        arguments.outpath = sys.stdout.buffer

    sources = [pcap.PcapReader(src) for src in arguments.inpaths]
    destination = pcap.PcapWriter(arguments.outpath)

    for packet in merge(sources, arguments.relative, arguments.time_offset):
        destination.write_packet(packet)


def filter_prog(argv):
    parser = argparse.ArgumentParser(prog="{0} {1}".format(argv[0], argv[1]), description="Filter packets from a capture.")
    parser.add_argument("-i", "--in", type=argparse.FileType("rb"), dest="infile", action="store", help="Input file")
    parser.add_argument("-o", "--out", type=argparse.FileType("wb"), dest="outfile", action="store", help="Output file")
    parser.add_argument("-p", "--permit", type=build_prototype_list, dest="permit_set", action="append", help="")
    parser.add_argument("-d", "--discard", type=build_prototype_list, dest="discard_set", action="append", help="")

    arguments = parser.parse_args(argv[2:])

    if arguments.infile == None:
        arguments.infile = sys.stdin.buffer
    if arguments.outfile == None:
        arguments.outfile = sys.stdout.buffer

    source = pcap.PcapReader(arguments.infile)
    destination = pcap.PcapWriter(arguments.outfile)

    for packet in filter(identify(source), permit=arguments.permit_set, discard=arguments.discard_set):
        destination.write_packet(packet)

    destination.close()


# Logical program entry point.
if __name__ == "__main__":
    progs = {
        "merge" : merge_prog,
        "filter" : filter_prog
    }

    if len(sys.argv) < 2 or sys.argv[1] not in progs:
        help_prog(sys.argv)
        exit(1)

    progs[sys.argv[1]](sys.argv)

